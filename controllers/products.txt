// actions/products.ts
"use server"

import Product , { IProduct } from "@/models/Product"
import { isValidCategory } from "@/lib/categoryValidation"
import mongoose from "mongoose"
import { connectToDB } from "@/lib/connectDB"
import { allProducts } from "@/constants/products"
import { ProductInterface } from "@/types/product"

export async function getProduct(category?: string, subcategory?: string): Promise<ProductInterface[]> {
  await connectToDB()
  const filter: Record<string, any> = {}
  if (category) filter.category = category
  if (subcategory) filter.subcategory = subcategory

  const products = await Product.find(filter)
    .populate("seller", "name rating") // ✅ populate seller details
    .sort({ createdAt: -1 })
    .lean<ProductInterface[]>()

  return products.map((p) => ({
    _id: p._id.toString(),
    name: p.name,
    description: p.description,
    price: p.price,
    location: p.location,
    seller: {
      _id: p.seller?._id?.toString() || "",
      name: (p.seller as any)?.name || "Seller",
      rating: (p.seller as any)?.rating || 0,
    },
    images: p.images || [],
    category: p.category,
    subcategory: p.subcategory,
    boosted: p.boosted,
    condition: p.condition,
    negotiable: p.negotiable,
    stats: p.stats,
    details: p.details || {},
    createdAt: new Date(p.createdAt),
    updatedAt: new Date(p.updatedAt),
  }))
}



// ✅ Get product by ID
export async function getProductById(id: string): Promise<ProductInterface | null> {
  await connectToDB()
  if (!mongoose.Types.ObjectId.isValid(id)) return null

  const p = await Product.findById(id)
    .populate("seller", "name rating") // populate seller details
    .lean()

  if (!p) return null

  return {
    _id: p._id.toString(),
    name: p.name,
    description: p.description,
    price: p.price,
    location: p.location,
    seller: {
      _id: p.seller?._id?.toString() || "",
      name: (p.seller as any)?.name || "Seller",
      rating: (p.seller as any)?.rating || 0,
    },
    images: p.images || [],
    category: p.category,
    subcategory: p.subcategory,
    boosted: p.boosted,
    condition: p.condition,
    negotiable: p.negotiable,
    stats: p.stats,
    details: p.details || {},
    createdAt: new Date(p.createdAt),
    updatedAt: new Date(p.updatedAt),
  }
}


export async function getProducts({
  categorySlug,
  subcategoryId,
  sortBy,
  search,
}: {
  categorySlug?: string
  subcategoryId?: string
  sortBy?: "newest" | "price-low" | "price-high" | "rating"
  search?: string
}) {
  let filtered = allProducts;

  if (categorySlug) {
    filtered = filtered.filter((p) => p.categorySlug === categorySlug)
  }
  if (subcategoryId) {
    filtered = filtered.filter((p) => p.subcategoryId === subcategoryId)
  }
  if (search) {
    filtered = filtered.filter((p) =>
      p.title.toLowerCase().includes(search.toLowerCase())
    )
  }

  switch (sortBy) {
    case "price-low":
      filtered = filtered.sort((a, b) => a.price - b.price)
      break
    case "price-high":
      filtered = filtered.sort((a, b) => b.price - a.price)
      break
    case "rating":
      filtered = filtered.sort((a, b) => b.rating - a.rating)
      break
    case "newest":
    default:
      filtered = filtered.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
      break
  }

  return filtered
}




// ✅ Create product
export async function createProduct(data: any) {
    await connectToDB()

    if (!isValidCategory(data.category, data.subcategory)) {
        throw new Error("Invalid category or subcategory")
    }

    const product = await Product.create(data)
    return JSON.parse(JSON.stringify(product))
}

// ✅ Update product
export async function updateProduct(id: string, data: any) {
    await connectToDB()
    if (!mongoose.Types.ObjectId.isValid(id)) return null

    const updated = await Product.findByIdAndUpdate(id, data, { new: true })
    return updated ? JSON.parse(JSON.stringify(updated)) : null
}

// ✅ Delete product
export async function deleteProduct(id: string) {
    await connectToDB()
    if (!mongoose.Types.ObjectId.isValid(id)) return null

    return await Product.findByIdAndDelete(id)
}
